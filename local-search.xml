<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ubuntu美化教程2-美化并增强linux的终端功能</title>
    <link href="/2024/07/28/%E7%BE%8E%E5%8C%96%E5%B9%B6%E5%A2%9E%E5%BC%BAlinux%E7%9A%84%E7%BB%88%E7%AB%AF%E5%8A%9F%E8%83%BD/"/>
    <url>/2024/07/28/%E7%BE%8E%E5%8C%96%E5%B9%B6%E5%A2%9E%E5%BC%BAlinux%E7%9A%84%E7%BB%88%E7%AB%AF%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="/img/linux_shell/zsh.png" alt="这是配置好之后的效果图"><br>可以看出，它不仅有自动提示功能，还可以显示出时间、系统信息等，甚至还可以显示你的git文件的状态（有几个在暂存区、几个还没同步等等）。我的安装由<a href="https://xxyqwq.github.io/2023/07/31/build-linux-terminal/">元神</a>的博客和网上的<a href="https://blog.csdn.net/m0_72357534/article/details/135453423">资料</a>整合而成。</p><h2 id="安装要求"><a href="#安装要求" class="headerlink" title="安装要求"></a>安装要求</h2><ol><li>linux操作系统，我用的是ubuntu22.04版本。</li><li>需要电脑上装有git、vim和curl，否则使用指令安装。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install git<br><span class="hljs-built_in">sudo</span> apt install vim<br><span class="hljs-built_in">sudo</span> apt install curl<br></code></pre></td></tr></table></figure></li><li>需要VPN或者使用镜像网站。</li></ol><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="更换linux字体"><a href="#更换linux字体" class="headerlink" title="更换linux字体"></a>更换linux字体</h3><p>首先我们需要安装<code>Hack Nerd Fonts</code>，这是适配powerlevel10k的字体，安装时间可能会在5分钟左右。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/ryanoasis/nerd-fonts.git<br><span class="hljs-built_in">cd</span> nerd-fonts<br><span class="hljs-built_in">chmod</span> +x install.sh <span class="hljs-comment"># 给执行权限</span><br>./install.sh <span class="hljs-comment"># 安装字体</span><br>reboot <span class="hljs-comment"># 重启系统</span><br></code></pre></td></tr></table></figure><p>接下来打开终端，找到右上角三个点，点开并选择配置文件首选项，再点击未命名，在自定义字体这一栏找到Hack Nerd Fonts字体并选择。</p><h3 id="安装zshell"><a href="#安装zshell" class="headerlink" title="安装zshell"></a>安装zshell</h3><ol><li>用apt安装zsh，检查它的可用性。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install zsh<br><span class="hljs-built_in">cat</span> /etc/shells <span class="hljs-comment"># 输出里面有/usr/bin/zsh</span><br></code></pre></td></tr></table></figure></li><li>用curl安装oh-my-zsh，并修改默认shell为zsh。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span><br>chsh -s /bin/zsh <span class="hljs-comment"># 修改默认shell</span><br>reboot <span class="hljs-comment"># 重启系统以加载修改</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$SHELL</span> <span class="hljs-comment"># 输出为/bin/zsh则修改成功</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="安装并配置powerlevel10k"><a href="#安装并配置powerlevel10k" class="headerlink" title="安装并配置powerlevel10k"></a>安装并配置<code>powerlevel10k</code></h3><ol><li>下载<code>powerlevel10k</code> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/romkatv/powerlevel10k.git <span class="hljs-variable">$ZSH_CUSTOM</span>/themes/powerlevel10k<br></code></pre></td></tr></table></figure></li><li>更改主题为<code>powerlevel10k</code> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim ~/.zshrc<br></code></pre></td></tr></table></figure> 找到<code>ZSH_THEME=&quot;robbyrussell&quot;</code>这一行，将其注释掉并加上 <figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot;<br>POWERLEVEL9K_MODE=&quot;awesome-patched&quot;<br></code></pre></td></tr></table></figure> 如果有修改点不动的情况，建议学习一下vim的基础操作。<br> 退出修改，执行 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.zshrc <span class="hljs-comment"># 使配置生效</span><br></code></pre></td></tr></table></figure> 接下来便会进入引导配置环节。如果没有进入引导配置或是配置好以后想重新配置的，输入下列命令： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">p10k configure<br></code></pre></td></tr></table></figure> 配置的具体选择见<a href="https://blog.csdn.net/m0_72357534/article/details/135453423">资料</a>，里面有每个问题详细的解释。</li></ol><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>从github上下载两个插件<code>zsh-autosuggestions</code>和<code>zsh-syntax-highlighting</code>，分别用于自动补全和自动高亮。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="hljs-variable">$ZSH_CUSTOM</span>/plugins/zsh-autosuggestions<br>git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="hljs-variable">$ZSH_CUSTOM</span>/plugins/zsh-syntax-highlighting<br></code></pre></td></tr></table></figure><p>接下来通过修改<code>.zshrc</code>来配置插件，和上面一样，输入<code>vim ~/.zshrc</code>，找到<code>plugins=(git)</code>这一行，将其修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">plugins=(git zsh-autosuggestions zsh-syntax-highlighting)<br></code></pre></td></tr></table></figure><p>再执行<code>source ~/.zshrc</code>来同步配置就可以了！</p><h2 id="插件使用以及小提示"><a href="#插件使用以及小提示" class="headerlink" title="插件使用以及小提示"></a>插件使用以及小提示</h2><ul><li><p>当你输入执行过的命令时，<code>zsh</code>会以灰色提示你，按<code>→</code>或<code>ctrl+f</code>可自动补全。</p></li><li><p>如果在别的要使用命令行的应用（比如vscode）里，要把字体都改成<code>Hack Nerd Fonts</code>。</p></li><li><p>如果已经在<code>~/.bashrc</code>中配置了一些环境变量，记得把它们都复制到<code>~/.zshrc</code>中。否则某一天你会发现：conda不见了！cuda不见了！</p></li><li><p>由于<code>zsh</code>使用了<code>globbing character</code>，即特殊通配符的语法，因此在执行某些指令的时候会提示<code>command not found</code>。下面列出了一些基本语法和一个例子。</p><table><thead><tr><th>字符</th><th>解释</th></tr></thead><tbody><tr><td><code>*</code></td><td>匹配任意长度任意字符</td></tr><tr><td><code>?</code></td><td>匹配任意单个字符</td></tr><tr><td><code>[list]</code></td><td>匹配指定范围内（list）任意单个字符，也可以是单个字符组成的集合</td></tr><tr><td><code>[^list]</code>或<code>[!list]</code></td><td>匹配指定范围外的任意单个字符或字符集合</td></tr></tbody></table><p>我在复现<a href="https://github.com/opendatalab/MinerU">这个代码</a>的时候，装环境用的指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install magic-pdf[full-cpu]<br></code></pre></td></tr></table></figure><p>在<code>zsh</code>找不到，究其原因是<code>[]</code>匹配了<code>globbing</code>语法。<br>有好几种解决方式：</p><ul><li>把含有特殊的符号（<code>*</code>、<code>?</code>、<code>[]</code>）的语句用双引号或单引号括起来，比如这样:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install <span class="hljs-string">&quot;magic-pdf[full-cpu]&quot;</span><br></code></pre></td></tr></table></figure></li><li>在运行指令之前用<code>setopt no_nomatch</code>来关闭<code>globbing</code>语法。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">setopt</span> no_nomatch<br>pip install magic-pdf[full-cpu]<br></code></pre></td></tr></table></figure>这里只是粗略的说一下，关于双引号和单引号的使用还有一些要求，详细的介绍请见<a href="https://www.cnblogs.com/divent/p/5762154.html">这里</a>。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>beautification</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu美化教程1</title>
    <link href="/2024/07/27/ubuntu-22-04%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B/"/>
    <url>/2024/07/27/ubuntu-22-04%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="/img/ubuntu_beautification/desktop.png" alt="完成后的效果"><br>美化后的桌面与mac的桌面几乎一致，比ubuntu原生桌面好看了不少。我的操作过程大体上基于<a href="https://www.youtube.com/watch?v=2kPC9HSBrPQ">视频</a>，但改进并增加了dock和桌面的内容。</p><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><ul><li>linux操作系统，我用的是ubuntu22.04版本</li><li>需要VPN，因为要在github上下载插件</li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>我用的是edge浏览器，因此跳过了视频中的卸载重装firefox的过程，实测edge也可以完成以下操作（当然可以跟着它把firefox卸掉）。</p><h3 id="安装Gnome-Tweaks"><a href="#安装Gnome-Tweaks" class="headerlink" title="安装Gnome Tweaks"></a>安装Gnome Tweaks</h3><p>指令为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install gnome-tweaks<br></code></pre></td></tr></table></figure><p>接着就可以在应用程序列表的工具那一栏找到它，他的中文名称叫“优化”。</p><h3 id="安装Chrome-gnome-shell"><a href="#安装Chrome-gnome-shell" class="headerlink" title="安装Chrome-gnome-shell"></a>安装Chrome-gnome-shell</h3><p>指令为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install chrome-gnome-shell<br></code></pre></td></tr></table></figure><p>接下来安装浏览器扩展功能。在浏览器中访问gnome官方<a href="https://extensions.gnome.org/">网站</a>，点击紫色框中的click here，在弹出的提示中选择continue to install，接下来的选项选择允许在私人窗口运行即可。<br><img src="/img/ubuntu_beautification/gnome-shell.png" alt="安装步骤示意"></p><h3 id="安装苹果风格任务栏"><a href="#安装苹果风格任务栏" class="headerlink" title="安装苹果风格任务栏"></a>安装苹果风格任务栏</h3><p>这里需要特别注意！！<strong>千万不要像视频里一样下载dash to dock!!</strong> 因为我自己使用的时候发现，它会导致挂起过久之后linux系统崩溃，具体表现为不能按windows键，否则就会整机卡死只能重启。我关闭dash to dock以后就没有这个问题了。</p><p>实际上不需要dash to dock也可以达到不错的效果。在设置–外观–Dock中调整，选择自动隐藏dock、关闭面板模式、将其调到底部，再点击“配置dock行为”，将显示卷和设备、显示回收站的按钮全部关闭，你就获得了一个不错的dock栏。<br><img src="/img/ubuntu_beautification/dock.png" alt="dock配置"></p><h3 id="安装苹果风格的应用主题"><a href="#安装苹果风格的应用主题" class="headerlink" title="安装苹果风格的应用主题"></a>安装苹果风格的应用主题</h3><p>访问这个<a href="https://gnome-look.org/">网站</a>，在左边框点击“GTK3&#x2F;4 theme”，再下拉右边栏找到“popularity“，点进排名第一的“White Sur GTK theme”，点进去，并在右边download选择有箭头的那一项，点击就可以进入github找到release，下载最新版本并解压缩、运行即可。具体指令如下：<br><img src="/img/ubuntu_beautification/gtk_theme.jpg" alt="下载选择"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 解压缩指令</span><br><span class="hljs-built_in">sudo</span> tar zxvf 下载/WhiteSur-gtk-theme-2024-05-01.tar.gz<br><span class="hljs-built_in">cd</span> WhiteSur-gtk-theme-2024-05-01 <span class="hljs-comment"># 进入目录</span><br><span class="hljs-built_in">sudo</span> ./install.sh <span class="hljs-comment"># 下载指令</span><br></code></pre></td></tr></table></figure><p>完成上述步骤后，打开tweaks（即”优化“），在外观–应用程序即可找到刚刚下载的一系列WhiteSur主题，选择你喜欢的！</p><h3 id="安装苹果风格的图标主题"><a href="#安装苹果风格的图标主题" class="headerlink" title="安装苹果风格的图标主题"></a>安装苹果风格的图标主题</h3><p>还是这个<a href="https://gnome-look.org/">网站</a>，在左边框找到“Full icon themes”，点击并下拉找到“WhiteSur Icon Themes”，在右边download选择“01-WhiteSur.tar.xz”下载。<br>这个需要自己创建icons文件夹，具体指令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> .icons; <span class="hljs-built_in">cd</span> .icons<br><span class="hljs-built_in">sudo</span> tar xvJf ~/下载/01-WhiteSur.tar.xz<br></code></pre></td></tr></table></figure><p>完成上述步骤后，打开tweaks，在外观–图标即可找到刚刚下载的一系列WhiteSur主题，选择你喜欢的！</p><h3 id="安装苹果风格的光标主题"><a href="#安装苹果风格的光标主题" class="headerlink" title="安装苹果风格的光标主题"></a>安装苹果风格的光标主题</h3><p>还还是这个<a href="https://gnome-look.org/">网站</a>，在左边框找到“Cursors”，点击并下拉找到”Popularity“，找到“WhiteSur cursors”并下载。<br>这个安装可以使用上一步创建的.icons文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> .icons<br><span class="hljs-built_in">sudo</span> tar xvJf ~/下载/WhiteSur-cursors.tar.xz<br></code></pre></td></tr></table></figure><p>完成上述步骤后，打开tweaks，在外观–光标即可找到刚刚下载的WhiteSur主题，选择它！</p><h3 id="安装苹果风格的shell主题"><a href="#安装苹果风格的shell主题" class="headerlink" title="安装苹果风格的shell主题"></a>安装苹果风格的shell主题</h3><p>进入gnome官方<a href="https://extensions.gnome.org/">网站</a>，选择第一个“Users Themes”，点进去将off改为on即可自动下载。<br>完成上述步骤后，打开tweaks，在外观–shell即可找到WhiteSur主题，选择你喜欢的！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这一篇主要讲解了如何将ubuntu美化为macOS的样子，下一篇来讲怎么进一步美化并增强shell的功能。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>beautification</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>经典单调队列问题</title>
    <link href="/2024/07/27/leetcode-main239/"/>
    <url>/2024/07/27/leetcode-main239/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><blockquote><p>Problem: <a href="https://leetcode.cn/problems/sliding-window-maximum/description/">239：滑动窗口最大值</a><br>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字，且滑动窗口每次只向右移动一位。<br>返回每个滑动窗口看到的最大值的序列。</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这种题看上去就要用单调队列来减少时间复杂度。</p><p>朴素的想法是一次遍历，每次拿出最大值的过程应该是O(k)的时间复杂度。但实际上每次滑动框移动一次，<strong>（最多）只会导致一个老元素过时和一个新元素出现</strong>，所以在每次遍历拿出最大值的过程中，会重复扫描很多元素。于是我们可以维护一个单调递减的队列q，将每次取最大值的时间复杂度降为$O(1)$。</p><p>每次滑动框移动一次，都会导致一个老元素过时和一个新元素出现，我们只需要在这个过程中维护单调递减队列。</p><h1 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h1><ol><li>在遍历的过程中，首先判断队首元素$q[0]$是否已经过时，如果过时就让其出列;</li><li>再考虑新元素加入队列的过程，由于新元素一定要在队列中，于是从尾部开始pop队列的元素，直到新元素可以顺利加入并形成单调队列;</li><li>将队首元素$q[0]$加入$result$中。</li></ol><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度：$O(N)$</li><li>空间复杂度：$O(N)$</li></ul><h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><p>代码实现时，这种双端都要进出的结构应该用deque（双端队列）实现。<a href="https://blog.csdn.net/qq_21989927/article/details/109403054">这里</a>有deque的基本用法介绍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights, <span class="hljs-type">int</span> limit)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        deque&lt;<span class="hljs-type">int</span>&gt; q;<br><br>        <span class="hljs-keyword">if</span>(heights.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> res; <span class="hljs-comment">//空队列情况</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= heights.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i - limit &gt;= <span class="hljs-number">0</span> &amp;&amp; q[<span class="hljs-number">0</span>] == heights[i - limit]) <span class="hljs-comment">//要被剔除</span><br>            &#123;<br>                q.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br>            <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>() &amp;&amp; q.<span class="hljs-built_in">back</span>() &lt; heights[i]) <span class="hljs-comment">//将列表中所有小于加入元素的数删掉，以保证队列的递减性</span><br>            &#123;<br>                q.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            q.<span class="hljs-built_in">push_back</span>(heights[i]); <span class="hljs-comment">//加入新元素</span><br><br>            <span class="hljs-keyword">if</span>(i &gt;= limit - <span class="hljs-number">1</span>) res.<span class="hljs-built_in">push_back</span>(q[<span class="hljs-number">0</span>]); <span class="hljs-comment">//在窗口完整后，向res中加答案</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>mono-queue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划解决正则匹配问题</title>
    <link href="/2024/07/27/leetcode_main10_LCR317/"/>
    <url>/2024/07/27/leetcode_main10_LCR317/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><blockquote><p>Problem: <a href="https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/description/">LCR 137. 模糊搜索验证</a><br>设计一个程序来支持用户在文本编辑器中的模糊搜索功能。用户输入内容中可能使用到如下两种通配符：</p><ul><li>‘.’ 匹配任意单个字符。</li><li>‘*’ 匹配零个或多个前面的那一个元素。</li></ul><p>请返回用户输入内容 input 所有字符是否可以匹配原文字符串 article。</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这题是一个正则匹配题，可以用动态规划来解决。具体来说，$dp[i][j]$表示$s$的前$i-1$项和$p$的前$j-1$项是否可以匹配，我们要通过$dp[a][b](a\leq i, b\leq j)来计算得出它$。注意这里假设字符串的第0位为空，因此$dp[0][0]$一定为true，它代表了两个空字符串是可以匹配的。</p><h1 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>我们可以考虑初始化第一行还是初始化第一列。<br>对第一列来说，除了$dp[0][0]$为true之外其他的一定都是false,因为一个非空的真实字符串不可能匹配一个空的模糊字符串；但是第一行不一样，一个非空的模糊字符串是可能匹配一个空的字符串的，例如“空”和“a*”就是匹配的。于是我们选择初始化第一列：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>(); <span class="hljs-type">int</span> m = p.<span class="hljs-built_in">size</span>();<br>vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)); <span class="hljs-comment">// 初始化dp全都为false</span><br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//空序列对空序列，可以匹配</span><br></code></pre></td></tr></table></figure><p>由于我们初始化的是第一列，因此我们计算动态规划的顺序应该为先对列遍历，再对行遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)  <span class="hljs-comment">// 计算dp[i][j]的值</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= n; i++)&#123;&#125;<br>            ...<br>        &#125;<br></code></pre></td></tr></table></figure><h2 id="转移方程"><a href="#转移方程" class="headerlink" title="转移方程"></a>转移方程</h2><p>我们可以根据 $p[j-1]$ 的值来进行分类讨论：</p><h3 id="p-j-1-”-”"><a href="#p-j-1-”-”" class="headerlink" title="$p[j-1]$&#x3D;”*”"></a>$p[j-1]$&#x3D;”*”</h3><p>这个情况比较复杂，需要考虑三种情况：</p><ol><li><p><strong><code>*</code>前面的字母出现0次是否匹配</strong>：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> a = (j &gt;= <span class="hljs-number">2</span>) &amp;&amp; dp[i][j - <span class="hljs-number">2</span>]; <span class="hljs-comment">// 0个*前的字母是否使其成立</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>*</code>前面的字母出现一次或者一次以上是否匹配</strong>：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> b = (i &gt;= <span class="hljs-number">1</span>) &amp;&amp; (j &gt;= <span class="hljs-number">2</span>) &amp;&amp; dp[i - <span class="hljs-number">1</span>][j] &amp;&amp; (p[j - <span class="hljs-number">2</span>] == s[i - <span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure></li><li><p><strong><code>*</code>前面的字母是”.”时，只需要考虑</strong>：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> c = (i &gt;= <span class="hljs-number">1</span>) &amp;&amp; dp[i - <span class="hljs-number">1</span>][j];<br></code></pre></td></tr></table></figure></li></ol><p>只要 <code>a</code>, <code>b</code>, <code>c</code> 中有一个为 <code>true</code>，那么 <code>$dp[i][j]$</code> 就为 <code>true</code>。</p><h3 id="p-j-1-”-”-1"><a href="#p-j-1-”-”-1" class="headerlink" title="$p[j-1]$&#x3D;”.”"></a>$p[j-1]$&#x3D;”.”</h3><p>只要前一个序列相互配对即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">dp[i][j] = (i &gt;= <span class="hljs-number">1</span>) &amp;&amp; dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><h3 id="p-j-1-字母"><a href="#p-j-1-字母" class="headerlink" title="$p[j-1]$&#x3D;字母"></a>$p[j-1]$&#x3D;字母</h3><p>这样更简单，只要当前字母匹配且前一个序列可以相互匹配就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">dp[i][j] = (i &gt;= <span class="hljs-number">1</span>) &amp;&amp; dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &amp;&amp; (s[i - <span class="hljs-number">1</span>] == p[j - <span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><p>不难发现2.1的b，c两种情况可以结合，结合之后就得到了正确完整的的代码。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(mn)$</li><li>空间复杂度: $O(mn)$</li><li>这题应该可以用状态压缩把空间优化到$O(\max(m,n))$的，但我没去写，什么时候把它补上。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">articleMatch</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>(); <span class="hljs-type">int</span> m = p.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)); <span class="hljs-comment">// 初始化dp全都为false</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//空序列对空序列，可以匹配</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)  <span class="hljs-comment">// 计算dp[i][j]的值</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= n; i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-type">bool</span> a = (j &gt;= <span class="hljs-number">2</span>) &amp;&amp; dp[i][j - <span class="hljs-number">2</span>]; <span class="hljs-comment">// 0个*前的字母是否使其成立</span><br>                    <span class="hljs-type">bool</span> b = (i &gt;= <span class="hljs-number">1</span>) &amp;&amp; (j &gt;= <span class="hljs-number">2</span>) &amp;&amp; dp[i - <span class="hljs-number">1</span>][j] &amp;&amp; ((p[j - <span class="hljs-number">2</span>] == s[i - <span class="hljs-number">1</span>]) || p[j - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;.&#x27;</span>);  <br>                    <span class="hljs-comment">//  &gt;=1个*前的字母是否使其成立，或者是特殊情况p[j - 2] = &#x27;.&#x27;</span><br>                    dp[i][j] = a || b;            <br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span>) dp[i][j] = (i &gt;= <span class="hljs-number">1</span>) &amp;&amp; dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 是&#x27;.&#x27;</span><br>                <span class="hljs-keyword">else</span> dp[i][j] = (i &gt;= <span class="hljs-number">1</span>) &amp;&amp; dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &amp;&amp; (s[i - <span class="hljs-number">1</span>] == p[j - <span class="hljs-number">1</span>]); <span class="hljs-comment">// 是字母</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[n][m];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>dp</category>
      
      <category>regular matching</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux上的vscode、git与github的互联工作流</title>
    <link href="/2024/07/26/git&amp;github/"/>
    <url>/2024/07/26/git&amp;github/</url>
    
    <content type="html"><![CDATA[<h1 id="一、介绍与要求"><a href="#一、介绍与要求" class="headerlink" title="一、介绍与要求"></a>一、介绍与要求</h1><ol><li>介绍：我刚刚改到linux系统（ubuntu22.04）上进行学习和工作，深感到linux的方便快捷，于是想在此记录以下git和github的学习过程，也权当备忘录。</li><li>要求：强烈建议使用梯子（VPN）进行操作，否则git指令很可能会卡顿，因为github的服务器在国外。本文默认电脑上已经装好git和vscode、已注册git的用户名和邮箱。</li></ol><h1 id="二、git和github联动"><a href="#二、git和github联动" class="headerlink" title="二、git和github联动"></a>二、git和github联动</h1><h2 id="2-1-git与github的连接"><a href="#2-1-git与github的连接" class="headerlink" title="2.1  git与github的连接"></a>2.1  git与github的连接</h2><p>首先输入指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa -C &quot;git注册的邮箱&quot;<br></code></pre></td></tr></table></figure><p>然后根据它的提示按三下回车，出现一个图案就表示密钥生成成功。在主文件夹（即&#x2F;home&#x2F;用户名称&#x2F;）下找到id_rsa.pub文件，进入其中将它的内容<strong>全部</strong>复制下来。</p><p>切换到github界面中，点击你的头像–Settings–SSH and GPG keys（在左边框上），点击new ssh key，在这个界面中，title就是你给这个密钥的命名，比如说这个是我linux设备的密钥，我就给他命名为“linux”，并把刚刚复制的公钥粘贴到key那个框中，点击add ssh key即可连接git与你的giyhub账号。<br><img src="/img/github&vscode/ssh_key.png" alt="ssh key添加界面"></p><p>接下来在git中验证这件事。输入指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -T git@github.com<br></code></pre></td></tr></table></figure><p>第一次用这个命令需要输入一个”yes”，当出现你的github账号就代表连接成功！</p><p><img src="/img/github&vscode/success_connect.png" alt="成功连接！"></p><h2 id="2-2-git的操作"><a href="#2-2-git的操作" class="headerlink" title="2.2 git的操作"></a>2.2 git的操作</h2><p>这里以我在学习的Coursera的HTML课程为例，来实现git的基本操作。</p><ol><li>拉取远程库 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone &quot;https或ssh&quot;<br></code></pre></td></tr></table></figure> https或ssh</li></ol><p>  <img src="/img/github&vscode/ssh.png" alt="ssh网址">的具体位置在github库的这里，点进库中选择code键即可看见。</p><p>我想拉取这个库的指令为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone git@github.com:kingdom-of-warriors/Coursera-HTML.git<br></code></pre></td></tr></table></figure><ol start="2"><li>添加暂存区<br> 在修改文件后，应将它添加到暂存区。执行git status查看，修改过的文件应该是红色的。</li></ol>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add &quot;改动的文件&quot;<br>git add . # 表示提交所有更改<br></code></pre></td></tr></table></figure><p>  再执行指令<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add index.html<br></code></pre></td></tr></table></figure><br>  后执行git status查看，这个文件将会变为绿色。</p><ol start="3"><li><p>提交本地库</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git commit -m &quot;日志信息&quot;<br></code></pre></td></tr></table></figure><p>  这个日志信息一般来说是描述你这次更改改了哪些地方，写什么都行。在本例中，我想表示我增加了css渲染内容，那么应该写的指令是</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git commit -m &quot;增加css渲染内容&quot;<br></code></pre></td></tr></table></figure></li><li><p>创建别名<br> 在github上创建一个新仓库，像2.2.1那样找到它的SSH或者HTTPS（我更推荐用SSH连接）。这个别名主要是为了<strong>方便推送代码</strong>，相当于给一大段复杂的网址取了一个别名，用这个别名就相当于在用这个网址，所以别名最好短小精悍一点。</p></li></ol><p>  一般来说，github会给你的仓库去一个默认的别名叫origin，可以通过git remote -v 来查看。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote add 别名 &quot;SSH或HTTPS网址&quot;<br></code></pre></td></tr></table></figure><p>  如果我想给这个github仓库取一个别名叫HTML，那么指令应该如下：<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote add HTML git@github.com:kingdom-of-warriors/Coursera-HTML.git<br></code></pre></td></tr></table></figure><br>  然后执行git remote -v就可以查看别名是否添加成功。<br>  <img src="/img/github&vscode/other_name.png" alt="别名添加成功"></p><ol start="5"><li>推送代码<br> 使用别名可以很快的推送代码，指令为</li></ol>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push 别名 分支名<br></code></pre></td></tr></table></figure><p>  在本例中指令为<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push HTML main<br></code></pre></td></tr></table></figure><br>  如果不用别名，指令将会是<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push git@github.com:kingdom-of-warriors/Coursera-HTML.git main<br></code></pre></td></tr></table></figure><br>  ，从此处也可以看出别名的方便之处。</p><h1 id="三、vscode与git的方便操作（待更新）"><a href="#三、vscode与git的方便操作（待更新）" class="headerlink" title="三、vscode与git的方便操作（待更新）"></a>三、vscode与git的方便操作（待更新）</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里的git操作介绍全部基于尚硅谷的<a href="https://www.bilibili.com/video/BV1vy4y1s7k6/?spm_id_from=333.999.0.0&vd_source=217dcc16f6693d64dbc48b7cfad6b2fa">课程</a>，想详细学习git的同学们可以去看！</p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
      <category>github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>git</tag>
      
      <tag>github</tag>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在ubuntu上部署Sabaki以及围棋引擎katago</title>
    <link href="/2024/07/26/sabaki&amp;katago/"/>
    <url>/2024/07/26/sabaki&amp;katago/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Sabaki的部署"><a href="#一、Sabaki的部署" class="headerlink" title="一、Sabaki的部署"></a>一、Sabaki的部署</h1><p>想要配置一个可以用于分析的图像界面katago，需要一个可视化的图形界面（Lizzieyzy、Sabaki等等）和katago引擎。在Ubuntu上，我推荐使用Sabaki，因为它下载即可打开使用，而Lizzieyzy虽然功能更齐全，但它需要java环境而且容易报错。</p><p><img src="/img/sabaki/sabaki.png" alt="Sabaki界面"></p><h2 id="1-1-下载Sabaki"><a href="#1-1-下载Sabaki" class="headerlink" title="1.1 下载Sabaki"></a>1.1 下载Sabaki</h2><p>Sabaki可在github上下载，下载各个版本的链接为<a href="https://github.com/SabakiHQ/Sabaki/releases/tag/v0.52.2">Sabaki</a>，对于Ubuntu选择<strong>linux-x64.AppImage</strong>的版本。在下载到本地后，右键“属性-权限”赋予它执行权限，点击即可运行。</p><h2 id="1-2-创造快捷方式"><a href="#1-2-创造快捷方式" class="headerlink" title="1.2 创造快捷方式"></a>1.2 创造快捷方式</h2><p>首先下载它的<a href="https://github.com/SabakiHQ/Sabaki/blob/master/logo.png">Logo</a>，然后创建.desktop文件，具体代码可参考如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs txt">[Desktop Entry]<br>Name=Sabaki<br>Exec=/path/to/Sabaki.AppImage<br>Icon=/path/to/logo.png<br>Terminal=false<br>Type=Application<br></code></pre></td></tr></table></figure><p>将其复制到桌面并赋予执行权限即可。</p><h1 id="二、下载katago"><a href="#二、下载katago" class="headerlink" title="二、下载katago"></a>二、下载katago</h1><p>接下来我们下载katago引擎，这里只考虑有独显的电脑的配置。我们有三种选择，从易到难分别为OpenCL、CUDA和Tensor RT版本，下面这三种都会介绍。<br><a href="https://github.com/lightvector/KataGo/releases/tag/v1.14.1">下载网址</a></p><h2 id="2-1-OpenCL版本"><a href="#2-1-OpenCL版本" class="headerlink" title="2.1 OpenCL版本"></a>2.1 OpenCL版本</h2><h3 id="2-1-1-下载OpenCL版katago引擎"><a href="#2-1-1-下载OpenCL版katago引擎" class="headerlink" title="2.1.1 下载OpenCL版katago引擎"></a>2.1.1 下载OpenCL版katago引擎</h3><p>如果你的电脑有一个不错的独显并且希望快速开始的话，OpenCL是最好的选择，它不需要配置CUDA或者cuDNN。<br>在<a href="https://github.com/lightvector/KataGo/releases/tag/v1.14.1">下载界面</a>选择katago-v1.14.1-opencl-linux-x64.zip这个安装包，其中后缀有bs29的是娱乐版本，它支持29 $\times$ 29的超大棋盘，不过对电脑性能的要求也更高，想玩的就可以下载带bs29的版本。<br>在合适的位置新建文件夹katago，在下面再新建一个文件夹katago_opencl，将这个安装包解压至katago_opencl下，结果如下所示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">├── katago_opencl<br>    ├── analysis_example.cfg<br>    ├── cacert.pem<br>    ├── contribute_example.cfg<br>    ├── default_gtp.cfg<br>    ├── katago<br>    ├── katago-v1.14.1-opencl-linux-x64.zip<br>    ├── match_example.cfg<br>    └── README.txt<br></code></pre></td></tr></table></figure><h3 id="2-1-2-下载katago权重"><a href="#2-1-2-下载katago权重" class="headerlink" title="2.1.2 下载katago权重"></a>2.1.2 下载katago权重</h3><p>有了引擎，还需要下载katago的权重<a href="https://katagotraining.org/networks/">下载地址</a>。其中标了绿色的那一行就是elo分最高（最厉害）的权重。在Network File下点击download，将下载下来的bin.gz文件剪切到katago&#x2F;katago_opencl文件夹下。<br><img src="/img/sabaki/weight.png" alt="权重下载网页"></p><h3 id="2-1-3-配置OpenCL版katago"><a href="#2-1-3-配置OpenCL版katago" class="headerlink" title="2.1.3 配置OpenCL版katago"></a>2.1.3 配置OpenCL版katago</h3><p>打开Sakabi，在左上角点开File-Preferences然后切换语言为中文并重启Sakabi。接着点开文件–首选项–引擎，新建文件夹sabari_log作为日志保存目录。<br>还是在引擎这里，点击“新增”，会出现四行需要我们填的东西，分别为：</p><ol><li>引擎的名字（任意取）</li><li>引擎路径：&#x2F;katago&#x2F;katago_opencl&#x2F;katago（这个katago文件的路径）</li><li>运行参数：gtp -model &lt;权重文件名&gt;.bin.gz -config default_gtp.cfg</li><li>启动参数：time_settings 0 5 1</li></ol><p>示例如下：<br><img src="/img/sabaki/opencl_para.png" alt="启动参数（参考）"><br>然后点击”关闭“，点击左上角的小三角并选中配置的引擎，就开始初始化啦。第一次初始化的时间会在两三分钟左右，耐心等待～～<br>出现”GTP ready, beginning main protocol loop“则配置成功！</p><h3 id="2-1-4-遇到问题及解决"><a href="#2-1-4-遇到问题及解决" class="headerlink" title="2.1.4 遇到问题及解决"></a>2.1.4 遇到问题及解决</h3><ol><li><p>问题：在初始化引擎的时候，我遇到了<strong>error while loading shared libraries: libzip.so.5: cannot open shared object file: No such file or directory</strong>的问题，这是因为linux系统缺少libzip5造成的。</p></li><li><p>解决：首先我们需要下载zlib库。zlib下载方式见这篇<a href="https://blog.csdn.net/lushixuan12345/article/details/122545491">blog</a>，不过注意把下载网址<a href="http://www.zlib.net/zlib-1.2.11.tar.gz%E6%94%B9%E4%B8%BAhttp://www.zlib.net/fossils/zlib-1.2.11.tar.gz%E3%80%82">http://www.zlib.net/zlib-1.2.11.tar.gz改为http://www.zlib.net/fossils/zlib-1.2.11.tar.gz。</a><br>有了zlib库后，这是libzip5的<a href="https://launchpad.net/ubuntu/+archive/primary/+sourcefiles/libzip/1.5.1-0ubuntu1/libzip_1.5.1.orig.tar.xz">下载网址</a>，我们根据这篇<a href="https://blog.csdn.net/iamhuanyu/article/details/129603632">blog</a>的步骤来下载libzip5，再在其中找到libzip.so.5文件，并创建<strong>软链接到&#x2F;usr&#x2F;lib&#x2F;上</strong>，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ln -s &quot;libzip.so.5文件所在位置&quot; /usr/lib/libzip.so.5<br><span class="hljs-meta prompt_"># </span><span class="language-bash">比如我的电脑中，命令应该为：</span><br>sudo ln -s /usr/local/lib/libzip.so.5 /usr/lib/libzip.so.5<br></code></pre></td></tr></table></figure><p>其他同类型的报错解决方式也是如出一辙。先在电脑中找找有没有该文件，如果有就创建软链接，如果没有就下载所需要的库，再创建相应的软链接。</p></li></ol><h2 id="2-2-CUDA版本"><a href="#2-2-CUDA版本" class="headerlink" title="2.2 CUDA版本"></a>2.2 CUDA版本</h2><p>CUDA版本的katago比OpenCL版本的强不少，不过安装起来也更复杂，需要安装CUDA和cuDNN两个东西。</p><h3 id="2-2-1-CUDA安装"><a href="#2-2-1-CUDA安装" class="headerlink" title="2.2.1 CUDA安装"></a>2.2.1 CUDA安装</h3><p>在katago引擎的<a href="https://github.com/lightvector/KataGo/releases/tag/v1.14.1">下载链接</a>找到有cuda和cudnn的那个版本，发现最新版需要12.1的CUDA和8.9.7的cuDNN。在电脑上通过</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nvidia-smi<br></code></pre></td></tr></table></figure><p>来查看是否支持12.1的CUDA版本（显示的值要大于等于12.1，我这里是12.2），如果比12.1低的话可以下载更低版本的引擎。<br><img src="/img/sabaki/nvidia-smi.png" alt="指令输出，右上角显示12.2"></p><p>于是我们在官网找到CUDA12.1的<a href="https://developer.nvidia.com/cuda-12-1-0-download-archive">下载网址</a>，选择”linux–x86_64–Ubuntu–22.04–runfile(local)”（这个要根据具体ubuntu版本进行调整），下面就会出现安装的指令。<br><img src="/img/sabaki/cuda.png" alt="命令行安装" title="命令行安装cuda"><br>运行.run文件后会出现一个图形化的安装界面，可以根据<a href="https://blog.csdn.net/Sihang_Xie/article/details/127347139">这篇文章</a>的指导来做，总之就是在安装的时候<strong>不要点上安装驱动</strong>，否则很容易导致nvidia驱动损坏。</p><h3 id="2-2-2-遇到问题及解决"><a href="#2-2-2-遇到问题及解决" class="headerlink" title="2.2.2 遇到问题及解决"></a>2.2.2 遇到问题及解决</h3><ol><li>问题：在运行.run文件时，我遇到了安装失败的问题，安装日志显示</li></ol><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">[INFO]: md5 matches, removing file /var/log/nvidia/.uninstallManifests/CUDA_Toolkit_10.2-components/CUDA_Tools_10.2-components/CUDA_Visual_Tools_10.2-components/<br>[ERROR]: boost::filesystem::remove: Directory not empty: &quot;/var/log/nvidia/.uninstallManifests/CUDA_Toolkit_10.2-components/CUDA_Tools_10.2-components/CUDA_Visual_Tools_10.2-components/&quot;<br></code></pre></td></tr></table></figure><ol start="2"><li>解决：在查询<a href="https://tieba.baidu.com/p/6848132251">资料</a>后，我发现在运行.run文件的指令后应该加上一些参数，具体指令如下：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo sh cuda_12.1.0_530.30.02_linux.run --silent --toolkit --samples --librarypath=/usr/local/cuda-12.1<br></code></pre></td></tr></table></figure><p>这条指令运行的时候不会弹出图形界面，在等待一会后运行完成，把~&#x2F;.bashrc文件更新一下后，通过nvcc -V来看CUDA是否安装成功。（更新bashrc文件的过程详见<a href="https://blog.csdn.net/Sihang_Xie/article/details/127347139">上面这篇文章</a>）</p><ol start="3"><li>这个问题正常情况下是不会出现的。</li></ol><h3 id="2-2-2-cuDNN安装"><a href="#2-2-2-cuDNN安装" class="headerlink" title="2.2.2 cuDNN安装"></a>2.2.2 cuDNN安装</h3><p>这是cuDNN8.9.7的x86<a href="https://developer.nvidia.com/downloads/compute/cudnn/secure/8.9.7/local_installers/12.x/cudnn-linux-x86_64-8.9.7.29_cuda12-archive.tar.xz/">下载链接</a>，也可以在<a href="https://developer.nvidia.cn/rdp/cudnn-archive">官网</a>上找到下载别的版本的cuDNN，不过这个网址可能需要你注册一个nvidia帐号。</p><p>接下来的具体下载步骤可以参考<a href="https://blog.csdn.net/enjoyyl/article/details/134893210">这篇文章</a>，为了方便起见，我将安装指令粘贴过来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -xvf cudnn-linux-x86_64-8.9.7.29_cuda12-archive.tar.xz<br>sudo cp cudnn-*-archive/include/cudnn*.h /usr/local/cuda/include <br>sudo cp -P cudnn-*-archive/lib/libcudnn* /usr/local/cuda/lib64 <br>sudo chmod a+r /usr/local/cuda/include/cudnn*.h /usr/local/cuda/lib64/libcudnn*<br></code></pre></td></tr></table></figure><h3 id="2-2-3-CUDA版本的引擎安装"><a href="#2-2-3-CUDA版本的引擎安装" class="headerlink" title="2.2.3 CUDA版本的引擎安装"></a>2.2.3 CUDA版本的引擎安装</h3><p>与本文2.1.1和2.1.2章过程一样，在katago目录下创建一个katago_cuda文件夹，将引擎文件解压后放入其中，同时也要把权重文件也放入其中，这里不再赘述，下面是成功后的katago目录下的文件：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs txt">katago<br>├── katago_cuda<br>│   ├── analysis_example.cfg<br>│   ├── cacert.pem<br>│   ├── contribute_example.cfg<br>│   ├── default_gtp.cfg<br>│   ├── kata1-b28c512nbt-s7168446720-d4316919285.bin.gz<br>│   ├── katago<br>│   ├── match_example.cfg<br>│   └── README.txt<br>└── katago_opencl<br>    ├── analysis_example.cfg<br>    ├── cacert.pem<br>    ├── contribute_example.cfg<br>    ├── default_gtp.cfg<br>    ├── kata1-b28c512nbt-s7168446720-d4316919285.bin.gz<br>    ├── katago<br>    ├── match_example.cfg<br>    └── README.txt<br></code></pre></td></tr></table></figure><h3 id="2-2-4-配置CUDA版katago"><a href="#2-2-4-配置CUDA版katago" class="headerlink" title="2.2.4 配置CUDA版katago"></a>2.2.4 配置CUDA版katago</h3><p>过程与本文2.1.3一样，下面给出我的配置：<br><img src="/img/sabaki/cuda_para.png" alt="cuda版的启动参数配置"><br>在配置完成后点左上三角即可初始化引擎，等待看是否报错&#x2F;配置成功。</p><h3 id="2-2-5-遇到问题及解决"><a href="#2-2-5-遇到问题及解决" class="headerlink" title="2.2.5 遇到问题及解决"></a>2.2.5 遇到问题及解决</h3><ol><li>问题：在初始化引擎的时候，我遇到了<strong>error while loading shared libraries: libcudnn.so.8: cannot open shared object file: No such file or directory</strong>的问题，这是因为我们下载cudnn后没有将其移动到文件夹中。</li><li>解决：通过<strong>查找文件名</strong>找到我们刚刚下载的cudnn中的libcudnn_cnn_infer.so.8文件，并建立软链接即可解决。</li></ol>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
      <category>katago</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>katago</tag>
      
      <tag>围棋</tag>
      
      <tag>sabaki</tag>
      
      <tag>人工智能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/07/26/hello-world/"/>
    <url>/2024/07/26/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
